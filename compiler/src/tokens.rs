use std::fmt;

// TODO: use this to only derive in tests
// #[cfg_attr(test, derive(Debug))]
#[derive(Debug, Copy, Clone)]
pub enum Token {
  Arrow(usize, usize),
  BinaryDigits(usize, usize),
  Colon(usize, usize),
  Comma(usize, usize),
  Comment(usize, usize),
  DecimalDigits(usize, usize),
  Dot(usize, usize),
  DoubleArrow(usize, usize),
  DoubleColon(usize, usize),
  Equals(usize, usize),
  HexDigits(usize, usize),
  IdentifierLower(usize, usize),
  IdentifierUpper(usize, usize),
  ImportPath(usize, usize),
  InterpolationEnd(usize, usize),
  InterpolationStart(usize, usize),
  KeywordAlias(usize, usize),
  KeywordAs(usize, usize),
  KeywordBreak(usize, usize),
  KeywordDef(usize, usize),
  KeywordEnum(usize, usize),
  KeywordLet(usize, usize),
  KeywordMatch(usize, usize),
  KeywordPrivate(usize, usize),
  KeywordReturn(usize, usize),
  KeywordStruct(usize, usize),
  KeywordTrait(usize, usize),
  KeywordUse(usize, usize),
  KeywordWhere(usize, usize),
  LeftBrace(usize, usize),
  LeftBracket(usize, usize),
  LeftParen(usize, usize),
  LineBreak(usize, usize),
  OctalDigits(usize, usize),
  Operator(usize, usize),
  Pipe(usize, usize),
  RightBrace(usize, usize),
  RightBracket(usize, usize),
  RightParen(usize, usize),
  StringLiteral(usize, usize),
  Unexpected(usize, usize),
}

impl Token {
  pub fn get_location(&self) -> (usize, usize) {
    match self {
      &Token::Arrow(start, end) => (start, end),
      &Token::BinaryDigits(start, end) => (start, end),
      &Token::Colon(start, end) => (start, end),
      &Token::Comma(start, end) => (start, end),
      &Token::Comment(start, end) => (start, end),
      &Token::DecimalDigits(start, end) => (start, end),
      &Token::Dot(start, end) => (start, end),
      &Token::DoubleArrow(start, end) => (start, end),
      &Token::DoubleColon(start, end) => (start, end),
      &Token::Equals(start, end) => (start, end),
      &Token::HexDigits(start, end) => (start, end),
      &Token::IdentifierLower(start, end) => (start, end),
      &Token::IdentifierUpper(start, end) => (start, end),
      &Token::ImportPath(start, end) => (start, end),
      &Token::InterpolationEnd(start, end) => (start, end),
      &Token::InterpolationStart(start, end) => (start, end),
      &Token::KeywordAlias(start, end) => (start, end),
      &Token::KeywordAs(start, end) => (start, end),
      &Token::KeywordBreak(start, end) => (start, end),
      &Token::KeywordDef(start, end) => (start, end),
      &Token::KeywordEnum(start, end) => (start, end),
      &Token::KeywordLet(start, end) => (start, end),
      &Token::KeywordMatch(start, end) => (start, end),
      &Token::KeywordPrivate(start, end) => (start, end),
      &Token::KeywordReturn(start, end) => (start, end),
      &Token::KeywordStruct(start, end) => (start, end),
      &Token::KeywordTrait(start, end) => (start, end),
      &Token::KeywordUse(start, end) => (start, end),
      &Token::KeywordWhere(start, end) => (start, end),
      &Token::LeftBrace(start, end) => (start, end),
      &Token::LeftBracket(start, end) => (start, end),
      &Token::LeftParen(start, end) => (start, end),
      &Token::LineBreak(start, end) => (start, end),
      &Token::OctalDigits(start, end) => (start, end),
      &Token::Operator(start, end) => (start, end),
      &Token::Pipe(start, end) => (start, end),
      &Token::RightBrace(start, end) => (start, end),
      &Token::RightBracket(start, end) => (start, end),
      &Token::RightParen(start, end) => (start, end),
      &Token::StringLiteral(start, end) => (start, end),
      &Token::Unexpected(start, end) => (start, end),
    }
  }
}

impl fmt::Display for Token {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let as_string = match self {
      &Token::Arrow(..) => "->",
      &Token::BinaryDigits(..) => "binary digits",
      &Token::Colon(..) => ":",
      &Token::Comma(..) => ",",
      &Token::Comment(..) => "comment",
      &Token::DecimalDigits(..) => "digits",
      &Token::Dot(..) => ".",
      &Token::DoubleArrow(..) => "=>",
      &Token::DoubleColon(..) => "::",
      &Token::Equals(..) => "=",
      &Token::HexDigits(..) => "hex digits",
      &Token::IdentifierLower(..) => "identifier",
      &Token::IdentifierUpper(..) => "type identifier",
      &Token::ImportPath(..) => "import path",
      &Token::InterpolationEnd(..) => ")",
      &Token::InterpolationStart(..) => "$(",
      &Token::KeywordAlias(..) => "alias",
      &Token::KeywordAs(..) => "as",
      &Token::KeywordBreak(..) => "break",
      &Token::KeywordDef(..) => "def",
      &Token::KeywordEnum(..) => "enum",
      &Token::KeywordLet(..) => "let",
      &Token::KeywordMatch(..) => "match",
      &Token::KeywordPrivate(..) => "private",
      &Token::KeywordReturn(..) => "return",
      &Token::KeywordStruct(..) => "struct",
      &Token::KeywordTrait(..) => "trait",
      &Token::KeywordUse(..) => "use",
      &Token::KeywordWhere(..) => "where",
      &Token::LeftBrace(..) => "{",
      &Token::LeftBracket(..) => "[",
      &Token::LeftParen(..) => "(",
      &Token::LineBreak(..) => "line break",
      &Token::OctalDigits(..) => "octal digits",
      &Token::Operator(..) => "operator",
      &Token::Pipe(..) => "|",
      &Token::RightBrace(..) => "}",
      &Token::RightBracket(..) => "]",
      &Token::RightParen(..) => ")",
      &Token::StringLiteral(..) => "string",
      &Token::Unexpected(..) => "unknown",
    };

    write!(f, "{}", as_string)
  }
}
